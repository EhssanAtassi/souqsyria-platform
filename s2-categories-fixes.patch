diff --git a/apps/backend/src/categories/controllers/categories-public.controller.ts b/apps/backend/src/categories/controllers/categories-public.controller.ts
index 704c539..f61ad0a 100644
--- a/apps/backend/src/categories/controllers/categories-public.controller.ts
+++ b/apps/backend/src/categories/controllers/categories-public.controller.ts
@@ -35,8 +35,9 @@ import {
   Res,
 } from '@nestjs/common';
 import { ApiOperation, ApiParam, ApiQuery, ApiResponse, ApiTags } from '@nestjs/swagger';
+import { InjectRepository } from '@nestjs/typeorm';
 import { Request, Response } from 'express';
-import { IsNull } from 'typeorm';
+import { IsNull, Repository } from 'typeorm';
 import { Public } from '../../common/decorators/public.decorator';
 
 // Import Services
@@ -48,6 +49,9 @@ import { PublicProductsService } from '../../products/public/service/public-prod
 // Import DTOs and Types
 import { CategoryQueryDto, ApprovalStatus, GetCategoriesTreeResponseDto, CategoryTreeRootDto, CategoryTreeChildDto, CategoryTreeGrandchildDto, PaginatedCategoriesResponseDto, SearchWithinCategoryDto } from '../dto/index-dto';
 
+// Import Entities
+import { Category } from '../entities/category.entity';
+
 /**
  * PUBLIC CATEGORIES CONTROLLER
  *
@@ -70,6 +74,8 @@ export class CategoriesPublicController {
     private readonly categorySearchService: CategorySearchService,
     private readonly categoryHierarchyService: CategoryHierarchyService,
     private readonly publicProductsService: PublicProductsService,
+    @InjectRepository(Category)
+    private readonly categoryRepository: Repository<Category>,
   ) {
     this.logger.log('üåê Public Categories Controller initialized');
   }
@@ -1099,22 +1105,418 @@ export class CategoriesPublicController {
   }
 
   // ============================================================================
-  // SEARCH WITHIN CATEGORY (SS-CAT-006)
+  // NEW S2 ENDPOINTS (Place BEFORE :id/products due to route order)
+  // ============================================================================
+
+  /**
+   * GET CATEGORY BY SLUG
+   *
+   * Retrieves a single category by its slug identifier.
+   * Returns category details with parent, children, and product count.
+   * Only returns categories that are active and approved.
+   *
+   * Features:
+   * - Lookup by slug instead of numeric ID
+   * - Includes parent and children relationships
+   * - Product count for the category
+   * - Cached for 5 minutes
+   * - Mobile-optimized response
+   *
+   * Use Cases:
+   * - Frontend category page routing (e.g., /categories/damascus-steel)
+   * - SEO-friendly category URLs
+   * - Category navigation breadcrumbs
+   * - Category metadata for product listings
+   *
+   * @sprint S2 Categories Backend Gaps
+   */
+  @Get('by-slug/:slug')
+  @ApiParam({
+    name: 'slug',
+    type: String,
+    description: 'Category slug identifier (e.g., "damascus-steel", "electronics")',
+    example: 'damascus-steel',
+  })
+  @ApiOperation({
+    summary: 'Get category by slug',
+    description: `
+      Retrieve a single category by its slug identifier.
+
+      Features:
+      ‚Ä¢ SEO-friendly slug-based lookup
+      ‚Ä¢ Includes parent and children relationships
+      ‚Ä¢ Product count for the category
+      ‚Ä¢ Only returns active and approved categories
+      ‚Ä¢ Cached for 5 minutes for optimal performance
+
+      Use Cases:
+      ‚Ä¢ Frontend category page routing
+      ‚Ä¢ SEO-friendly category URLs
+      ‚Ä¢ Category navigation breadcrumbs
+      ‚Ä¢ Category metadata for product listings
+    `,
+  })
+  @ApiResponse({
+    status: 200,
+    description: 'Category retrieved successfully',
+    schema: {
+      example: {
+        success: true,
+        data: {
+          id: 1,
+          nameEn: 'Damascus Steel',
+          nameAr: 'ÿßŸÑŸÅŸàŸÑÿßÿ∞ ÿßŸÑÿØŸÖÿ¥ŸÇŸä',
+          slug: 'damascus-steel',
+          descriptionEn: 'Authentic Damascus steel knives and blades',
+          descriptionAr: 'ÿ≥ŸÉÿßŸÉŸäŸÜ Ÿàÿ¥ŸÅÿ±ÿßÿ™ ÿ£ÿµŸÑŸäÿ© ŸÖŸÜ ÿßŸÑŸÅŸàŸÑÿßÿ∞ ÿßŸÑÿØŸÖÿ¥ŸÇŸä',
+          bannerUrl: 'https://images.unsplash.com/photo-1589698423558',
+          iconUrl: 'hardware',
+          parent: null,
+          children: [
+            {
+              id: 10,
+              nameEn: 'Kitchen Knives',
+              nameAr: 'ÿ≥ŸÉÿßŸÉŸäŸÜ ÿßŸÑŸÖÿ∑ÿ®ÿÆ',
+              slug: 'kitchen-knives',
+              productCount: 15,
+            },
+          ],
+          productCount: 25,
+        },
+      },
+    },
+    headers: {
+      'Cache-Control': {
+        description: 'Caching directive for performance',
+        schema: { type: 'string', example: 'public, max-age=300' },
+      },
+    },
+  })
+  @ApiResponse({
+    status: 404,
+    description: 'Category not found or not publicly available',
+    schema: {
+      example: {
+        success: false,
+        error: 'Not Found',
+        message: 'Category with slug "invalid-slug" not found',
+        statusCode: 404,
+      },
+    },
+  })
+  async getCategoryBySlug(
+    @Param('slug') slug: string,
+    @Res() response: Response,
+  ) {
+    const startTime = Date.now();
+
+    this.logger.log(`üîç Get category by slug request: slug="${slug}"`);
+
+    try {
+      // 1. Find category by slug
+      const category = await this.categoriesService.findBySlug(slug);
+
+      if (!category) {
+        return response.status(HttpStatus.NOT_FOUND).json({
+          success: false,
+          error: 'Not Found',
+          message: `Category with slug "${slug}" not found`,
+          statusCode: HttpStatus.NOT_FOUND,
+        });
+      }
+
+      // 2. Set cache headers (5 minutes)
+      response.set({
+        'Cache-Control': 'public, max-age=300',
+        'X-Content-Type-Options': 'nosniff',
+      });
+
+      const processingTime = Date.now() - startTime;
+      this.logger.log(
+        `‚úÖ Category by slug retrieved: ${category.nameEn} (ID: ${category.id}) (${processingTime}ms)`,
+      );
+
+      // 3. Return category data
+      return response.status(HttpStatus.OK).json({
+        success: true,
+        data: {
+          id: category.id,
+          nameEn: category.nameEn,
+          nameAr: category.nameAr,
+          slug: category.slug,
+          descriptionEn: category.descriptionEn,
+          descriptionAr: category.descriptionAr,
+          bannerUrl: category.bannerUrl,
+          iconUrl: category.iconUrl,
+          parent: category.parent
+            ? {
+                id: category.parent.id,
+                nameEn: category.parent.nameEn,
+                nameAr: category.parent.nameAr,
+                slug: category.parent.slug,
+              }
+            : null,
+          children: (category.children || []).map((child) => ({
+            id: child.id,
+            nameEn: child.nameEn,
+            nameAr: child.nameAr,
+            slug: child.slug,
+            productCount: child.productCount,
+          })),
+          productCount: category.productCount,
+        },
+      });
+    } catch (error: unknown) {
+      const processingTime = Date.now() - startTime;
+
+      this.logger.error(
+        `‚ùå Get category by slug failed: ${(error as Error).message} (${processingTime}ms)`,
+        (error as Error).stack,
+      );
+
+      return response.status(HttpStatus.INTERNAL_SERVER_ERROR).json({
+        success: false,
+        error: 'Internal Server Error',
+        message: 'Failed to retrieve category. Please try again.',
+        statusCode: HttpStatus.INTERNAL_SERVER_ERROR,
+      });
+    }
+  }
+
+  /**
+   * GET CATEGORY HIERARCHY WITH BREADCRUMBS
+   *
+   * Retrieves category hierarchy information including breadcrumb path and children.
+   * Useful for navigation breadcrumbs and category exploration.
+   *
+   * Features:
+   * - Breadcrumb path from root to current category
+   * - List of child categories with product counts
+   * - Localized category names (English/Arabic)
+   * - Cached for 5 minutes
+   * - Mobile-optimized response
+   *
+   * Use Cases:
+   * - Category page breadcrumb navigation
+   * - Category tree exploration
+   * - Subcategory navigation menus
+   * - SEO breadcrumb markup
+   *
+   * @sprint S2 Categories Backend Gaps
+   */
+  @Get(':id/hierarchy')
+  @ApiParam({
+    name: 'id',
+    type: Number,
+    description: 'Category ID',
+    example: 1,
+  })
+  @ApiOperation({
+    summary: 'Get category hierarchy with breadcrumbs and children',
+    description: `
+      Retrieve category hierarchy information including breadcrumb path and children.
+
+      Features:
+      ‚Ä¢ Breadcrumb path from root to current category
+      ‚Ä¢ List of child categories with product counts
+      ‚Ä¢ Localized category names (English/Arabic)
+      ‚Ä¢ Only returns active and approved categories
+      ‚Ä¢ Cached for 5 minutes for optimal performance
+
+      Use Cases:
+      ‚Ä¢ Category page breadcrumb navigation
+      ‚Ä¢ Category tree exploration
+      ‚Ä¢ Subcategory navigation menus
+      ‚Ä¢ SEO breadcrumb markup
+    `,
+  })
+  @ApiQuery({
+    name: 'language',
+    required: false,
+    enum: ['en', 'ar'],
+    example: 'en',
+    description: 'Response language preference (default: en)',
+  })
+  @ApiResponse({
+    status: 200,
+    description: 'Category hierarchy retrieved successfully',
+    schema: {
+      example: {
+        success: true,
+        data: {
+          path: [
+            {
+              id: 1,
+              nameEn: 'Home & Garden',
+              nameAr: 'ÿßŸÑŸÖŸÜÿ≤ŸÑ ŸàÿßŸÑÿ≠ÿØŸäŸÇÿ©',
+              slug: 'home-garden',
+            },
+            {
+              id: 5,
+              nameEn: 'Kitchen',
+              nameAr: 'ÿßŸÑŸÖÿ∑ÿ®ÿÆ',
+              slug: 'kitchen',
+            },
+          ],
+          currentName: 'Kitchen',
+          children: [
+            {
+              id: 10,
+              nameEn: 'Cookware',
+              nameAr: 'ÿ£ÿØŸàÿßÿ™ ÿßŸÑÿ∑ÿ®ÿÆ',
+              slug: 'cookware',
+              productCount: 45,
+            },
+          ],
+        },
+      },
+    },
+    headers: {
+      'Cache-Control': {
+        description: 'Caching directive for performance',
+        schema: { type: 'string', example: 'public, max-age=300' },
+      },
+    },
+  })
+  @ApiResponse({
+    status: 404,
+    description: 'Category not found or not publicly available',
+  })
+  async getCategoryHierarchy(
+    @Param('id') id: number,
+    @Query('language') language: 'en' | 'ar' = 'en',
+    @Res() response: Response,
+  ) {
+    const startTime = Date.now();
+
+    this.logger.log(`üå≥ Get category hierarchy request: id=${id}, language=${language}`);
+
+    try {
+      // 1. Validate category ID
+      const sanitizedId = Number(id);
+      if (isNaN(sanitizedId) || sanitizedId < 1) {
+        throw new BadRequestException('Invalid category ID');
+      }
+
+      // 2. Validate language
+      const sanitizedLanguage: 'en' | 'ar' = ['en', 'ar'].includes(language) ? language : 'en';
+
+      // 3. Find category (must be active + approved)
+      const category = await this.categoryRepository.findOne({
+        where: {
+          id: sanitizedId,
+          isActive: true,
+          approvalStatus: 'approved' as 'draft' | 'pending' | 'approved' | 'rejected' | 'suspended' | 'archived',
+        },
+        relations: ['parent', 'children'],
+      });
+
+      if (!category) {
+        return response.status(HttpStatus.NOT_FOUND).json({
+          success: false,
+          error: 'Not Found',
+          message: `Category with ID ${sanitizedId} not found`,
+          statusCode: HttpStatus.NOT_FOUND,
+        });
+      }
+
+      // 4. Generate breadcrumbs using existing hierarchy service
+      const breadcrumbs = await this.categoryHierarchyService.generateBreadcrumbs(
+        category,
+        sanitizedLanguage,
+      );
+
+      // 5. Build path from breadcrumbs (need to fetch full category data for each breadcrumb)
+      const pathPromises = breadcrumbs.map(async (crumb) => {
+        const fullCategory = await this.categoryRepository.findOne({
+          where: { id: crumb.id },
+        });
+        return {
+          id: crumb.id,
+          nameEn: fullCategory?.nameEn || crumb.name,
+          nameAr: fullCategory?.nameAr || crumb.name,
+          slug: crumb.slug,
+        };
+      });
+      const path = await Promise.all(pathPromises);
+
+      // 6. Get children with product counts (only active + approved)
+      const children = (category.children || [])
+        .filter((child) => child.isActive && child.approvalStatus === 'approved')
+        .map((child) => ({
+          id: child.id,
+          nameEn: child.nameEn,
+          nameAr: child.nameAr,
+          slug: child.slug,
+          productCount: child.productCount,
+        }));
+
+      // 7. Set cache headers (5 minutes)
+      response.set({
+        'Cache-Control': 'public, max-age=300',
+        'X-Content-Type-Options': 'nosniff',
+      });
+
+      const processingTime = Date.now() - startTime;
+      this.logger.log(
+        `‚úÖ Category hierarchy retrieved: ${category.nameEn} with ${breadcrumbs.length} breadcrumbs, ${children.length} children (${processingTime}ms)`,
+      );
+
+      // 8. Return hierarchy data
+      return response.status(HttpStatus.OK).json({
+        success: true,
+        data: {
+          path,
+          currentName: sanitizedLanguage === 'ar' ? category.nameAr : category.nameEn,
+          children,
+        },
+      });
+    } catch (error: unknown) {
+      const processingTime = Date.now() - startTime;
+
+      this.logger.error(
+        `‚ùå Get category hierarchy failed: ${(error as Error).message} (${processingTime}ms)`,
+        (error as Error).stack,
+      );
+
+      if (error instanceof BadRequestException) {
+        return response.status(HttpStatus.BAD_REQUEST).json({
+          success: false,
+          error: 'Bad Request',
+          message: (error as Error).message,
+          statusCode: HttpStatus.BAD_REQUEST,
+        });
+      }
+
+      return response.status(HttpStatus.INTERNAL_SERVER_ERROR).json({
+        success: false,
+        error: 'Internal Server Error',
+        message: 'Failed to retrieve category hierarchy. Please try again.',
+        statusCode: HttpStatus.INTERNAL_SERVER_ERROR,
+      });
+    }
+  }
+
+  // ============================================================================
+  // SEARCH WITHIN CATEGORY (SS-CAT-006, Enhanced S2)
   // ============================================================================
 
   /**
    * SEARCH PRODUCTS WITHIN CATEGORY
    *
-   * Search for products within a specific category with pagination.
+   * Search for products within a specific category with advanced filtering.
    * Only returns products that are active, published, and approved.
    * Only searches within active and approved categories.
    *
    * Features:
    * - Full-text search on product names (English/Arabic) and descriptions
+   * - Sort by: newest, price (asc/desc), popularity, rating
+   * - Price range filtering (minPrice, maxPrice)
    * - Pagination with page and limit parameters
    * - Returns product images and pricing
    * - Caching headers for 5 minutes
    * - Mobile-optimized response format
+   * - Accepts category ID (number) OR slug (string)
    *
    * Use Cases:
    * - Category page product listings
@@ -1122,25 +1524,28 @@ export class CategoriesPublicController {
    * - Mobile app category browsing
    * - Product filtering within categories
    *
-   * @sprint S3 Categories
+   * @sprint S3 Categories, S2 Enhanced
    * @ticket SS-CAT-006
    */
   @Get(':id/products')
   @ApiParam({
     name: 'id',
-    type: Number,
-    description: 'Category ID to search within',
-    example: 1,
+    type: String,
+    description: 'Category ID (number) or slug (string) to search within',
+    example: 'damascus-steel',
   })
   @ApiOperation({
-    summary: 'Search products within a specific category',
+    summary: 'Search products within a specific category with advanced filtering',
     description: `
-      Search for products within a specific category with optional keyword search and pagination.
+      Search for products within a specific category with optional keyword search, sorting, price filtering, and pagination.
 
       Features:
       ‚Ä¢ Full-text search on product names (English/Arabic) and descriptions
+      ‚Ä¢ Sort by: newest, price (asc/desc), popularity, rating
+      ‚Ä¢ Price range filtering (minPrice, maxPrice)
       ‚Ä¢ Only returns active, published, and approved products
       ‚Ä¢ Category must be active and approved
+      ‚Ä¢ Accepts category ID (number) OR slug (string)
       ‚Ä¢ Pagination support with page and limit
       ‚Ä¢ Returns product images and pricing information
       ‚Ä¢ Cached for 5 minutes for optimal performance
@@ -1152,6 +1557,13 @@ export class CategoriesPublicController {
       ‚Ä¢ Searches across product nameEn, nameAr, and descriptions
       ‚Ä¢ Uses MySQL LIKE for flexible matching
 
+      Sorting Options:
+      ‚Ä¢ newest: Recently added products first (default)
+      ‚Ä¢ price_asc: Lowest price first
+      ‚Ä¢ price_desc: Highest price first
+      ‚Ä¢ popularity: Most viewed products first
+      ‚Ä¢ rating: Highest rated products first
+
       Use Cases:
       ‚Ä¢ Category page product listings
       ‚Ä¢ Category-specific product search
@@ -1183,6 +1595,29 @@ export class CategoriesPublicController {
     minimum: 1,
     maximum: 100,
   })
+  @ApiQuery({
+    name: 'sortBy',
+    required: false,
+    enum: ['newest', 'price_asc', 'price_desc', 'popularity', 'rating'],
+    description: 'Sort order for products (default: newest)',
+    example: 'price_asc',
+  })
+  @ApiQuery({
+    name: 'minPrice',
+    required: false,
+    type: Number,
+    description: 'Minimum price filter in SYP (inclusive)',
+    example: 10000,
+    minimum: 0,
+  })
+  @ApiQuery({
+    name: 'maxPrice',
+    required: false,
+    type: Number,
+    description: 'Maximum price filter in SYP (inclusive)',
+    example: 50000,
+    minimum: 0,
+  })
   @ApiResponse({
     status: 200,
     description: 'Products retrieved successfully',
@@ -1248,30 +1683,37 @@ export class CategoriesPublicController {
     description: 'Internal server error',
   })
   async searchProductsWithinCategory(
-    @Param('id') categoryId: number,
+    @Param('id') categoryIdOrSlug: string | number,
     @Query() query: SearchWithinCategoryDto,
     @Res() response: Response,
   ) {
     const startTime = Date.now();
-    const { search, page = 1, limit = 20 } = query;
+    const { search, page = 1, limit = 20, sortBy = 'newest', minPrice, maxPrice } = query;
 
     this.logger.log(
-      `üîç Search within category request: categoryId=${categoryId}, search="${search || 'all'}", page=${page}, limit=${limit}`,
+      `üîç Search within category request: categoryIdOrSlug=${categoryIdOrSlug}, search="${search || 'all'}", page=${page}, limit=${limit}, sortBy=${sortBy}, minPrice=${minPrice}, maxPrice=${maxPrice}`,
     );
 
     try {
-      // 1. Validate category ID
-      const sanitizedCategoryId = Number(categoryId);
-      if (isNaN(sanitizedCategoryId) || sanitizedCategoryId < 1) {
-        throw new BadRequestException('Invalid category ID');
+      // 1. Parse category ID or slug
+      let categoryIdentifier: number | string = categoryIdOrSlug;
+      const numericId = Number(categoryIdOrSlug);
+
+      // If it's a valid number, use it as numeric ID
+      if (!isNaN(numericId) && numericId > 0) {
+        categoryIdentifier = numericId;
       }
+      // Otherwise treat as slug (string)
 
-      // 2. Execute search via service
+      // 2. Execute search via service (service handles both ID and slug)
       const result = await this.categoriesService.searchWithinCategory(
-        sanitizedCategoryId,
+        categoryIdentifier,
         search,
         page,
         limit,
+        sortBy,
+        minPrice,
+        maxPrice,
       );
 
       // 3. Set cache headers (5 minutes)
@@ -1282,7 +1724,7 @@ export class CategoriesPublicController {
 
       const processingTime = Date.now() - startTime;
       this.logger.log(
-        `‚úÖ Search within category ${categoryId} completed: ${result.data.length}/${result.meta.total} products found (${processingTime}ms)`,
+        `‚úÖ Search within category ${categoryIdOrSlug} completed: ${result.data.length}/${result.meta.total} products found (${processingTime}ms)`,
       );
 
       // 4. Return response
@@ -1295,14 +1737,17 @@ export class CategoriesPublicController {
       const processingTime = Date.now() - startTime;
 
       this.logger.error(
-        `‚ùå Search within category ${categoryId} failed: ${(error as Error).message} (${processingTime}ms)`,
+        `‚ùå Search within category ${categoryIdOrSlug} failed: ${(error as Error).message} (${processingTime}ms)`,
         {
           error: (error as Error).message,
           stack: (error as Error).stack,
-          categoryId,
+          categoryIdOrSlug,
           search,
           page,
           limit,
+          sortBy,
+          minPrice,
+          maxPrice,
         },
       );
 
diff --git a/apps/backend/src/categories/dto/index-dto.ts b/apps/backend/src/categories/dto/index-dto.ts
index 5fb7e70..ac4cd40 100644
--- a/apps/backend/src/categories/dto/index-dto.ts
+++ b/apps/backend/src/categories/dto/index-dto.ts
@@ -32,7 +32,7 @@ export {
   CategoryParentDto,
   CategoryChildDto,
 } from './category-response.dto';
-export { SearchWithinCategoryDto } from './search-within-category.dto';
+export { SearchWithinCategoryDto, ProductSortBy } from './search-within-category.dto';
 
 // ============================================================================
 // DELETION AND RESTORATION DTOs (Comment out until files are created)
diff --git a/apps/backend/src/categories/dto/search-within-category.dto.ts b/apps/backend/src/categories/dto/search-within-category.dto.ts
index 00c27ac..68cee6f 100644
--- a/apps/backend/src/categories/dto/search-within-category.dto.ts
+++ b/apps/backend/src/categories/dto/search-within-category.dto.ts
@@ -15,14 +15,32 @@
  */
 
 import { ApiProperty } from '@nestjs/swagger';
-import { IsString, IsOptional, IsInt, Min, Max } from 'class-validator';
+import { IsString, IsOptional, IsInt, Min, Max, IsEnum, IsNumber } from 'class-validator';
 import { Type } from 'class-transformer';
 
+/**
+ * Product sort order options for category search
+ *
+ * Supported sorting strategies:
+ * - newest: Recently added products first (default)
+ * - price_asc: Lowest price first
+ * - price_desc: Highest price first
+ * - popularity: Most viewed products first
+ * - rating: Highest rated products first
+ */
+export enum ProductSortBy {
+  NEWEST = 'newest',
+  PRICE_ASC = 'price_asc',
+  PRICE_DESC = 'price_desc',
+  POPULARITY = 'popularity',
+  RATING = 'rating',
+}
+
 /**
  * Search Within Category Query Parameters
  *
  * Used for GET /api/categories/:id/products endpoint
- * Provides flexible search with pagination for products in a specific category
+ * Provides flexible search with pagination, sorting, and price filtering for products in a specific category
  */
 export class SearchWithinCategoryDto {
   /**
@@ -82,4 +100,65 @@ export class SearchWithinCategoryDto {
   @Max(100)
   @IsOptional()
   limit?: number = 20;
+
+  /**
+   * Sort order for product results
+   * Controls the order in which products are returned
+   *
+   * Options:
+   * - newest: Most recently added products first (createdAt DESC)
+   * - price_asc: Lowest price first (basePrice ASC)
+   * - price_desc: Highest price first (basePrice DESC)
+   * - popularity: Most viewed products first (viewCount DESC)
+   * - rating: Highest rated products first (averageRating DESC)
+   */
+  @ApiProperty({
+    description: 'Sort order for product results',
+    required: false,
+    enum: ProductSortBy,
+    default: ProductSortBy.NEWEST,
+    example: ProductSortBy.PRICE_ASC,
+    enumName: 'ProductSortBy',
+  })
+  @IsEnum(ProductSortBy)
+  @IsOptional()
+  sortBy?: ProductSortBy = ProductSortBy.NEWEST;
+
+  /**
+   * Minimum price filter (inclusive)
+   * Filters products with basePrice >= minPrice
+   * Must be greater than or equal to 0
+   * If provided with maxPrice, must be <= maxPrice
+   */
+  @ApiProperty({
+    description: 'Minimum price filter in SYP (inclusive)',
+    required: false,
+    type: Number,
+    minimum: 0,
+    example: 10000,
+  })
+  @Type(() => Number)
+  @IsNumber()
+  @Min(0)
+  @IsOptional()
+  minPrice?: number;
+
+  /**
+   * Maximum price filter (inclusive)
+   * Filters products with basePrice <= maxPrice
+   * Must be greater than or equal to 0
+   * If provided with minPrice, must be >= minPrice
+   */
+  @ApiProperty({
+    description: 'Maximum price filter in SYP (inclusive)',
+    required: false,
+    type: Number,
+    minimum: 0,
+    example: 50000,
+  })
+  @Type(() => Number)
+  @IsNumber()
+  @Min(0)
+  @IsOptional()
+  maxPrice?: number;
 }
diff --git a/apps/backend/src/categories/services/categories.service.ts b/apps/backend/src/categories/services/categories.service.ts
index 7f68d9f..8d58b15 100644
--- a/apps/backend/src/categories/services/categories.service.ts
+++ b/apps/backend/src/categories/services/categories.service.ts
@@ -831,9 +831,47 @@ export class CategoriesService {
   }
 
   /**
-   * SEARCH WITHIN CATEGORY (SS-CAT-006)
+   * FIND CATEGORY BY SLUG
    *
-   * Search for products within a specific category with pagination
+   * Retrieves a single category by its slug identifier.
+   * Only returns categories that are active and approved for public access.
+   *
+   * @param slug - Category slug (e.g., 'damascus-steel', 'electronics')
+   * @returns Category entity with parent and children relations, or null if not found
+   */
+  async findBySlug(slug: string): Promise<Category | null> {
+    this.logger.log(`Finding category by slug: ${slug}`);
+
+    try {
+      const category = await this.categoryRepository.findOne({
+        where: {
+          slug,
+          isActive: true,
+          approvalStatus: 'approved' as 'draft' | 'pending' | 'approved' | 'rejected' | 'suspended' | 'archived',
+        },
+        relations: ['parent', 'children'],
+      });
+
+      if (!category) {
+        this.logger.warn(`Category with slug "${slug}" not found or not public`);
+        return null;
+      }
+
+      this.logger.log(`‚úÖ Found category: ${category.nameEn} (ID: ${category.id})`);
+      return category;
+    } catch (error: unknown) {
+      this.logger.error(
+        `‚ùå Failed to find category by slug "${slug}": ${(error as Error).message}`,
+        (error as Error).stack,
+      );
+      return null;
+    }
+  }
+
+  /**
+   * SEARCH WITHIN CATEGORY (SS-CAT-006, S2 Enhanced)
+   *
+   * Search for products within a specific category with advanced filtering
    * Only returns products that are active, published, and approved
    * Only searches within active and approved categories
    *
@@ -841,22 +879,32 @@ export class CategoriesService {
    * - Full-text search on product nameEn, nameAr, and descriptions
    * - LEFT JOIN with product_descriptions for description search
    * - Pagination with total count
+   * - Sort by: newest, price (asc/desc), popularity, rating
+   * - Price range filtering (minPrice, maxPrice)
    * - Includes first product image
    * - Returns product pricing information
    * - MySQL LIKE for flexible search
+   * - Accepts category ID (number) OR slug (string)
    *
-   * @param categoryId - Category ID to search within
+   * @param categoryIdOrSlug - Category ID (number) or slug (string) to search within
    * @param search - Optional search keyword (min 2 chars recommended)
    * @param page - Page number (starts from 1)
    * @param limit - Items per page (max 100)
+   * @param sortBy - Sort order: 'newest' | 'price_asc' | 'price_desc' | 'popularity' | 'rating'
+   * @param minPrice - Minimum price filter (inclusive)
+   * @param maxPrice - Maximum price filter (inclusive)
    * @returns Paginated product results with metadata
    * @throws NotFoundException if category doesn't exist or isn't public
+   * @throws BadRequestException if minPrice > maxPrice
    */
   async searchWithinCategory(
-    categoryId: number,
+    categoryIdOrSlug: number | string,
     search: string | undefined,
     page: number,
     limit: number,
+    sortBy: 'newest' | 'price_asc' | 'price_desc' | 'popularity' | 'rating' = 'newest',
+    minPrice?: number,
+    maxPrice?: number,
   ): Promise<{
     data: Array<{
       id: number;
@@ -880,31 +928,51 @@ export class CategoriesService {
   }> {
     const startTime = Date.now();
     this.logger.log(
-      `üîç Searching products in category ${categoryId}: search="${search || 'all'}", page=${page}, limit=${limit}`,
+      `üîç Searching products in category ${categoryIdOrSlug}: search="${search || 'all'}", page=${page}, limit=${limit}, sortBy=${sortBy}, minPrice=${minPrice}, maxPrice=${maxPrice}`,
     );
 
     try {
-      // 1. Validate category exists and is public
-      const category = await this.categoryRepository.findOne({
-        where: { id: categoryId },
-      });
+      // 1. Resolve category (handle both ID and slug)
+      let category: Category | null = null;
+      let categoryId: number;
+
+      if (typeof categoryIdOrSlug === 'number') {
+        // Numeric ID provided
+        categoryId = categoryIdOrSlug;
+        category = await this.categoryRepository.findOne({
+          where: { id: categoryId },
+        });
+      } else {
+        // String slug provided
+        category = await this.findBySlug(categoryIdOrSlug);
+        if (category) {
+          categoryId = category.id;
+        }
+      }
 
       if (!category) {
-        throw new NotFoundException(`Category with ID ${categoryId} not found`);
+        throw new NotFoundException(`Category "${categoryIdOrSlug}" not found`);
       }
 
       if (!category.isActive || category.approvalStatus !== 'approved') {
         throw new NotFoundException(
-          `Category with ID ${categoryId} is not publicly available`,
+          `Category "${categoryIdOrSlug}" is not publicly available`,
         );
       }
 
-      // 2. Calculate pagination offset
+      // 2. Validate price filters
+      if (minPrice !== undefined && maxPrice !== undefined && minPrice > maxPrice) {
+        throw new BadRequestException(
+          `Minimum price (${minPrice}) cannot be greater than maximum price (${maxPrice})`,
+        );
+      }
+
+      // 3. Calculate pagination offset
       const sanitizedPage = Math.max(1, page || 1);
       const sanitizedLimit = Math.min(Math.max(1, limit || 20), 100);
       const offset = (sanitizedPage - 1) * sanitizedLimit;
 
-      // 3. Build TypeORM QueryBuilder for products
+      // 4. Build TypeORM QueryBuilder for products
       const queryBuilder = this.categoryRepository.manager
         .getRepository('ProductEntity')
         .createQueryBuilder('product')
@@ -925,7 +993,7 @@ export class CategoriesService {
         })
         .andWhere('product.is_deleted = :isDeleted', { isDeleted: false });
 
-      // 4. Apply search filter if provided
+      // 5. Apply search filter if provided
       if (search && search.trim().length > 0) {
         const searchTerm = `%${search.trim()}%`;
         queryBuilder.andWhere(
@@ -934,16 +1002,50 @@ export class CategoriesService {
         );
       }
 
-      // 5. Order by creation date (newest first)
-      queryBuilder.orderBy('product.createdAt', 'DESC');
+      // 6. Apply price filters if provided
+      if (minPrice !== undefined) {
+        queryBuilder.andWhere('pricing.basePrice >= :minPrice', { minPrice });
+      }
+      if (maxPrice !== undefined) {
+        queryBuilder.andWhere('pricing.basePrice <= :maxPrice', { maxPrice });
+      }
+
+      // 7. Apply sort order based on sortBy parameter
+      switch (sortBy) {
+        case 'price_asc':
+          // Lowest price first
+          queryBuilder.orderBy('pricing.basePrice', 'ASC');
+          break;
+        case 'price_desc':
+          // Highest price first
+          queryBuilder.orderBy('pricing.basePrice', 'DESC');
+          break;
+        case 'popularity':
+          // Most viewed products first, fallback to newest
+          queryBuilder
+            .orderBy('product.viewCount', 'DESC')
+            .addOrderBy('product.createdAt', 'DESC');
+          break;
+        case 'rating':
+          // Highest rated first (nulls last), fallback to newest
+          queryBuilder
+            .orderBy('product.averageRating', 'DESC', 'NULLS LAST')
+            .addOrderBy('product.createdAt', 'DESC');
+          break;
+        case 'newest':
+        default:
+          // Newest products first (default)
+          queryBuilder.orderBy('product.createdAt', 'DESC');
+          break;
+      }
 
-      // 6. Add pagination
+      // 8. Add pagination
       queryBuilder.skip(offset).take(sanitizedLimit);
 
-      // 7. Execute query and get total count
+      // 9. Execute query and get total count
       const [products, total] = await queryBuilder.getManyAndCount();
 
-      // 8. Transform results to response format
+      // 10. Transform results to response format
       const transformedData = products.map((product) => {
         // Get first image sorted by sortOrder
         const sortedImages = (product.images || []).sort(
@@ -966,12 +1068,12 @@ export class CategoriesService {
         };
       });
 
-      // 9. Calculate metadata
+      // 11. Calculate metadata
       const totalPages = Math.ceil(total / sanitizedLimit);
       const processingTime = Date.now() - startTime;
 
       this.logger.log(
-        `‚úÖ Found ${transformedData.length}/${total} products in category ${categoryId} (${processingTime}ms)`,
+        `‚úÖ Found ${transformedData.length}/${total} products in category ${categoryIdOrSlug} (${processingTime}ms)`,
       );
 
       return {
@@ -986,16 +1088,16 @@ export class CategoriesService {
     } catch (error: unknown) {
       const processingTime = Date.now() - startTime;
       this.logger.error(
-        `‚ùå Failed to search products in category ${categoryId}: ${(error as Error).message} (${processingTime}ms)`,
+        `‚ùå Failed to search products in category ${categoryIdOrSlug}: ${(error as Error).message} (${processingTime}ms)`,
         (error as Error).stack,
       );
 
-      if (error instanceof NotFoundException) {
+      if (error instanceof NotFoundException || error instanceof BadRequestException) {
         throw error;
       }
 
       throw new InternalServerErrorException(
-        `Failed to search products in category ${categoryId}`,
+        `Failed to search products in category ${categoryIdOrSlug}`,
       );
     }
   }
diff --git a/apps/frontend/src/app/features/category/component/category.component.html b/apps/frontend/src/app/features/category/component/category.component.html
index c39931d..a9645a2 100644
--- a/apps/frontend/src/app/features/category/component/category.component.html
+++ b/apps/frontend/src/app/features/category/component/category.component.html
@@ -51,23 +51,10 @@
 
       <!-- Breadcrumb Navigation -->
       @if (category()) {
-        <nav class="breadcrumb-nav mb-4">
-          <ol class="flex items-center space-x-2 text-sm text-gray-600">
-            <li>
-              <a routerLink="/" class="hover:text-golden-wheat-primary transition-colors">
-                <mat-icon class="text-base">home</mat-icon>
-              </a>
-            </li>
-            @for (crumb of category()!.breadcrumb; track crumb; let last = $last) {
-              <li class="flex items-center">
-                <mat-icon class="mx-2 text-gray-400 text-xs">chevron_right</mat-icon>
-                <span [class]="last ? 'text-golden-wheat-primary font-medium' : 'hover:text-gray-700'">
-                  {{ crumb }}
-                </span>
-              </li>
-            }
-          </ol>
-        </nav>
+        <app-breadcrumb
+          [items]="breadcrumbItems()"
+          [language]="'en'">
+        </app-breadcrumb>
       }
 
       <!-- Category Header -->
diff --git a/apps/frontend/src/app/features/category/component/category.component.ts b/apps/frontend/src/app/features/category/component/category.component.ts
index fff62a1..784d8bb 100644
--- a/apps/frontend/src/app/features/category/component/category.component.ts
+++ b/apps/frontend/src/app/features/category/component/category.component.ts
@@ -66,6 +66,7 @@ import { FilterSidebarComponent, FilterState } from '../../../shared/components/
 import { ProductsToolbarComponent, SortOption } from '../../../shared/components/products-toolbar/products-toolbar.component';
 import { ActiveFiltersChipsComponent } from '../../../shared/components/active-filters-chips/active-filters-chips.component';
 import { ProductRecommendationsCarouselComponent } from '../../../shared/components/product-recommendations-carousel/product-recommendations-carousel.component';
+import { BreadcrumbComponent, BreadcrumbItem } from '../../../shared/components/ui/breadcrumb/breadcrumb.component';
 
 // Services
 import { CategoryFacadeService } from '../services/category-facade.service';
@@ -161,7 +162,8 @@ import {
     FilterSidebarComponent,
     ProductsToolbarComponent,
     ActiveFiltersChipsComponent,
-    ProductRecommendationsCarouselComponent
+    ProductRecommendationsCarouselComponent,
+    BreadcrumbComponent
   ],
   templateUrl: './category.component.html',
   styleUrls: ['./category.component.scss']
@@ -235,6 +237,17 @@ export class CategoryComponent implements OnInit {
     return currentSlug ? getRelatedCategories(currentSlug, 4) : [];
   });
 
+  /** Breadcrumb items for navigation */
+  readonly breadcrumbItems = computed<BreadcrumbItem[]>(() => {
+    const response = this.productListingResponse();
+    if (!response?.category?.breadcrumb) return [];
+
+    return response.category.breadcrumb.map((label: string, index: number, arr: string[]) => ({
+      label,
+      url: index < arr.length - 1 ? (index === 0 ? '/' : `/category/${this.categorySlug()}`) : undefined
+    }));
+  });
+
   /** Current filters as FilterState */
   readonly currentFilters = computed<FilterState>(() => {
     const filters: FilterState = {};
@@ -249,7 +262,7 @@ export class CategoryComponent implements OnInit {
       filters.ratings = ratings;
     }
 
-    const authenticity: any = {};
+    const authenticity: { unesco?: boolean; handmade?: boolean; regional?: boolean } = {};
     if (this.onlyUnesco()) authenticity.unesco = true;
 
     const heritage = this.selectedHeritage();
@@ -260,7 +273,7 @@ export class CategoryComponent implements OnInit {
       filters.authenticity = authenticity;
     }
 
-    const availability: any = {};
+    const availability: { inStock?: boolean; outOfStock?: boolean } = {};
     const avail = this.selectedAvailability();
     if (avail.includes('in_stock')) availability.inStock = true;
     if (avail.includes('out_of_stock')) availability.outOfStock = true;
@@ -607,8 +620,15 @@ export class CategoryComponent implements OnInit {
 
   /**
    * Update SEO meta tags
+   * @param category Category information object with name, description, and slug
+   * @param products Array of products for the category
+   * @param totalProducts Total count of products
    */
-  private updateSEOTags(category: any, products: Product[], totalProducts: number): void {
+  private updateSEOTags(
+    category: { nameEn?: string; name?: string; nameAr?: string; nameArabic?: string; descriptionEn?: string; description?: string; slug: string },
+    products: Product[],
+    totalProducts: number
+  ): void {
     const seoTags = this.categoryFacade.generateSEOMetaTags(category, products, totalProducts);
 
     this.titleService.setTitle(seoTags.title);
@@ -635,8 +655,13 @@ export class CategoryComponent implements OnInit {
 
   /**
    * Update JSON-LD structured data
+   * @param category Category information object with name, description, and slug
+   * @param products Array of products for structured data
    */
-  private updateStructuredData(category: any, products: Product[]): void {
+  private updateStructuredData(
+    category: { nameEn?: string; name?: string; nameAr?: string; nameArabic?: string; descriptionEn?: string; description?: string; slug: string },
+    products: Product[]
+  ): void {
     if (!isPlatformBrowser(this.platformId)) return;
 
     // Remove existing structured data
diff --git a/apps/frontend/src/app/features/category/services/category.service.ts b/apps/frontend/src/app/features/category/services/category.service.ts
index b87d0b4..1e3dabe 100644
--- a/apps/frontend/src/app/features/category/services/category.service.ts
+++ b/apps/frontend/src/app/features/category/services/category.service.ts
@@ -158,9 +158,25 @@ export class CategoryService extends AbstractCategoryService {
   getProductsByCategory(request: ProductListingRequest): Observable<ProductListingResponse> {
     return environment.enableMockData || environment.forceOfflineMode
       ? this.getMockProductsByCategory(request)
-      : this.http.get<ProductListingResponse>(
+      : this.http.get<{success: boolean; data: any[]; meta: {page: number; limit: number; total: number; totalPages: number}}>(
           `${this.apiUrl}/categories/${request.categorySlug}/products`,
           { params: this.buildRequestParams(request) }
+        ).pipe(
+          map(response => ({
+            products: response.data,
+            pagination: {
+              page: response.meta.page,
+              limit: response.meta.limit,
+              total: response.meta.total,
+              totalPages: response.meta.totalPages,
+              hasNext: response.meta.page < response.meta.totalPages,
+              hasPrevious: response.meta.page > 1
+            },
+            appliedFilters: request.filters,
+            appliedSort: request.sort,
+            availableFilters: undefined,
+            category: undefined
+          } as ProductListingResponse))
         );
   }
 
@@ -254,19 +270,33 @@ export class CategoryService extends AbstractCategoryService {
   private buildRequestParams(request: ProductListingRequest): any {
     const params: any = {};
 
-    if (request.searchQuery) params.q = request.searchQuery;
+    if (request.searchQuery) params.search = request.searchQuery;
     if (request.pagination) {
       params.page = request.pagination.page;
       params.limit = request.pagination.limit;
     }
     if (request.sort) {
-      params.sortField = request.sort.field;
-      params.sortDirection = request.sort.direction;
+      // Map sort to backend sortBy format
+      const sortMap: Record<string, string> = {
+        'price-asc': 'price_asc',
+        'price-desc': 'price_desc',
+        'newest': 'newest',
+        'popularity': 'popularity',
+        'rating': 'rating',
+      };
+      params.sortBy = sortMap[`${request.sort.field}-${request.sort.direction}`] || request.sort.field || 'newest';
     }
     if (request.filters) {
-      // Add filter parameters
+      // Add price filter params
+      if (request.filters.priceRange) {
+        if (request.filters.priceRange.min > 0) params.minPrice = request.filters.priceRange.min;
+        if (request.filters.priceRange.max < Infinity) params.maxPrice = request.filters.priceRange.max;
+      }
+      // Add other filter parameters
       Object.keys(request.filters).forEach(key => {
-        params[key] = request.filters![key as keyof CategoryFilter];
+        if (key !== 'priceRange') {
+          params[key] = request.filters![key as keyof CategoryFilter];
+        }
       });
     }
 
@@ -283,7 +313,9 @@ export class CategoryService extends AbstractCategoryService {
   getCategoryInfo(categorySlug: string): Observable<any> {
     return environment.enableMockData || environment.forceOfflineMode
       ? this.getMockCategoryInfo(categorySlug)
-      : this.http.get<any>(`${this.apiUrl}/categories/${categorySlug}`);
+      : this.http.get<{success: boolean; data: any}>(`${this.apiUrl}/categories/by-slug/${categorySlug}`).pipe(
+          map(response => response.data)
+        );
   }
 
   /**
diff --git a/apps/frontend/src/environments/environment.prod.ts b/apps/frontend/src/environments/environment.prod.ts
index 9d6c728..9020504 100644
--- a/apps/frontend/src/environments/environment.prod.ts
+++ b/apps/frontend/src/environments/environment.prod.ts
@@ -11,6 +11,7 @@ export const environment = {
   apiUrl: 'https://api.souqsyria.com',
   productApiUrl: 'https://api.souqsyria.com/products',
   userApiUrl: 'https://api.souqsyria.com/users',
+  categoryApiUrl: 'https://api.souqsyria.com/categories',
   apiVersion: 'v1',
 
   // Performance Configuration
