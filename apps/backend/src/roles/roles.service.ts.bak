/**
 * @file roles.service.ts (Enhanced)
 * @description Enhanced service for managing roles with advanced features:
 * - Role templates for quick creation
 * - Bulk permission assignment
 * - User tracking and assignment management
 * - Role priority and hierarchy
 * - Permission conflict detection
 * - Security audit integration
 *
 * Performance targets:
 * - Get templates: <50ms
 * - Bulk assign permissions: <200ms
 * - Remove permission: <100ms
 * - List users with role: <200ms
 * - Update priority: <50ms
 *
 * @author SouqSyria Backend Team
 * @version 2.0.0
 */

import {
  Injectable,
  NotFoundException,
  Logger,
  BadRequestException,
  Inject,
  forwardRef,
} from '@nestjs/common';\nimport { InjectRepository } from '@nestjs/typeorm';\nimport { Repository, DataSource, In } from 'typeorm';\nimport { Role } from './entities/role.entity';\nimport { Permission } from '../access-control/entities/permission.entity';\nimport { RolePermission } from '../access-control/entities/role-permission.entity';\nimport { User } from '../users/entities/user.entity';\nimport { CreateRoleDto } from './dto/create-role.dto';\nimport { UpdateRoleDto } from './dto/update-role.dto';\nimport { BulkAssignPermissionsDto } from './dto/bulk-assign-permissions.dto';\nimport { UpdateRolePriorityDto } from './dto/update-role-priority.dto';\nimport { PaginatedResponseDto } from '../common/dto/paginated-response.dto';\nimport { SecurityAuditService } from '../access-control/security-audit/security-audit.service';\nimport { SecurityAuditAction, ResourceType } from '../access-control/entities/security-audit-log.entity';\nimport {\n  getRoleTemplates,\n  getRoleTemplateById,\n  RoleTemplate,\n} from './config/role-templates.config';\n\n/**
 * Interface for user assignment tracking
 */\nexport interface UserWithRole {\n  id: number;\n  email: string;\n  fullName: string;\n  role: Role | null;\n  assignedRole: Role | null;\n}\n\n/**
 * Interface for permission conflict detection result
 */\nexport interface PermissionConflict {\n  type: 'MISSING_DEPENDENCY' | 'CONFLICTING_ACTIONS' | 'REDUNDANT_PERMISSION';\n  severity: 'LOW' | 'MEDIUM' | 'HIGH';\n  message: string;\n  affectedPermissions: string[];\n  recommendation: string;\n}\n\n@Injectable()\nexport class RolesService {\n  private readonly logger = new Logger(RolesService.name);\n\n  constructor(\n    @InjectRepository(Role)\n    private readonly roleRepository: Repository<Role>,\n    @InjectRepository(Permission)\n    private readonly permissionRepository: Repository<Permission>,\n    @InjectRepository(RolePermission)\n    private readonly rolePermissionRepository: Repository<RolePermission>,\n    @InjectRepository(User)\n    private readonly userRepository: Repository<User>,\n    private readonly dataSource: DataSource,\n    @Inject(forwardRef(() => SecurityAuditService))\n    private readonly securityAuditService: SecurityAuditService,\n  ) {}\n\n  /**
   * Create a new role.\n   *\   * @param createRoleDto - Role creation data
   * @returns Created role entity
   *
   * @example
   * const role = await rolesService.create({\n   *   name: 'Marketing Manager',\n   *   description: 'Manages marketing campaigns',\n   *   priority: 40\n   * });\n   */\n  async create(createRoleDto: CreateRoleDto): Promise<Role> {\n    const role = this.roleRepository.create(createRoleDto);\n    const saved = await this.roleRepository.save(role);\n    this.logger.log(`Created new role: ${saved.name}`);\n\n    // Audit log\n    await this.logSecurityEvent(\n      SecurityAuditAction.ROLE_CREATED,\n      saved.id,\n      `Role created: ${saved.name}`,\n      { roleName: saved.name, priority: saved.priority },\n    );\n\n    return saved;\n  }\n\n  /**
   * Find all roles with optional search and pagination.\n   *\n   * @param query - Optional query parameters (search, page, limit)\n   * @returns Paginated list of roles with their permissions\n   *\   * @example\n   * const result = await rolesService.findAll({\n   *   search: 'manager',\n   *   page: 1,\n   *   limit: 20\n   * });\n   */\n  async findAll(query?: {\n    search?: string;\n    page?: number;\n    limit?: number;\n  }): Promise<PaginatedResponseDto<Role>> {\n    const { search, page = 1, limit = 10 } = query || {};\n\n    const qb = this.roleRepository\n      .createQueryBuilder('role')\n      .leftJoinAndSelect('role.rolePermissions', 'rolePermissions')\n      .leftJoinAndSelect('rolePermissions.permission', 'permission');\n\n    if (search) {\n      qb.where('role.name LIKE :search OR role.description LIKE :search', {\n        search: `%${search}%`,\n      });\n    }\n\n    const [data, total] = await qb\n      .skip((page - 1) * limit)\n      .take(limit)\n      .orderBy('role.priority', 'DESC') // Order by priority (highest first)\n      .addOrderBy('role.id', 'ASC')\n      .getManyAndCount();\n\n    return {\n      data,\n      total,\n      page,\n      limit,\n    };\n  }\n\n  /**
   * Find one role by ID with full permission details.\n   *\n   * @param id - Role ID\n   * @returns Role entity with permissions\n   * @throws NotFoundException if role not found\n   *\n   * @example\n   * const role = await rolesService.findOne(5);\n   * console.log(role.rolePermissions); // Array of permissions\n   */\n  async findOne(id: number): Promise<Role> {\n    const role = await this.roleRepository.findOne({\n      where: { id },\n      relations: ['rolePermissions', 'rolePermissions.permission'],\n    });\n    if (!role) {\n      this.logger.warn(`Role ID ${id} not found`);\n      throw new NotFoundException(`Role with ID ${id} not found`);\n    }\n    return role;\n  }\n\n  /**\n   * Update a role by ID.\n   * Prevents modification of system roles (isDefault=true).\n   *\n   * @param id - Role ID\n   * @param updateRoleDto - Update data\n   * @returns Updated role entity\n   * @throws BadRequestException if trying to modify system role\n   *\n   * @example\n   * const updated = await rolesService.update(5, {\n   *   name: 'Senior Marketing Manager',\n   *   description: 'Updated description'\n   * });\n   */\n  async update(id: number, updateRoleDto: UpdateRoleDto): Promise<Role> {\n    const role = await this.findOne(id);\n\n    // Prevent changing the 'isDefault' flag on default roles\n    if (role.isDefault && updateRoleDto.isDefault === false) {\n      this.logger.warn(`Attempt to unset isDefault on role ID ${id} denied`);\n      throw new BadRequestException(\n        'Cannot unset isDefault on a default system role.',\n      );\n    }\n\n    const originalName = role.name;\n    Object.assign(role, updateRoleDto);\n    const updated = await this.roleRepository.save(role);\n    this.logger.log(`Updated role ID ${id}`);\n\n    // Audit log\n    await this.logSecurityEvent(\n      SecurityAuditAction.ROLE_MODIFIED,\n      id,\n      `Role updated: ${originalName} -> ${updated.name}`,\n      { changes: updateRoleDto },\n    );\n\n    return updated;\n  }\n\n  /**\n   * Soft delete a role by ID.\n   * Prevents deletion of system roles and warns if users are assigned.\n   *\n   * @param id - Role ID\n   * @throws BadRequestException if system role or has active users\n   *\n   * @example\n   * await rolesService.remove(5);\n   */\n  async remove(id: number): Promise<void> {\n    const role = await this.findOne(id);\n\n    // Cannot delete system roles\n    if (role.isDefault) {\n      this.logger.warn(`Attempt to delete default role ID ${id} denied`);\n      throw new BadRequestException('Cannot delete a default system role.');\n    }\n\n    // Check if users are assigned to this role\n    const userCount = await this.getUserCountForRole(id);\n    if (userCount > 0) {\n      this.logger.warn(`Attempt to delete role ID ${id} with ${userCount} active users`);\n      throw new BadRequestException(\n        `Cannot delete role with ${userCount} active users. Please reassign users first.`,\n      );\n    }\n\n    await this.roleRepository.softRemove(role);\n    this.logger.warn(`Soft-deleted role ID ${id}`);\n\n    // Audit log\n    await this.logSecurityEvent(\n      SecurityAuditAction.ROLE_DELETED,\n      id,\n      `Role deleted: ${role.name}`,\n      { roleName: role.name },\n    );\n  }\n\n  /**
   * Clone a role and its permissions.\n   * Creates a copy with '_copy' suffix.\n   *\n   * @param roleId - Role ID to clone\n   * @returns Cloned role entity\n   * @throws BadRequestException if trying to clone system role\n   *\n   * @example\n   * const cloned = await rolesService.cloneRole(5);\n   * console.log(cloned.name); // 'Marketing Manager_copy'\n   */\n  async cloneRole(roleId: number): Promise<Role> {\n    const original = await this.findOne(roleId);\n\n    if (original.isDefault) {\n      this.logger.warn(`Attempt to clone default role ID ${roleId} denied`);\n      throw new BadRequestException('Cannot clone a default system role.');\n    }\n\n    const clone = this.roleRepository.create({\n      name: `${original.name}_copy`,\n      description: original.description,\n      priority: original.priority,\n    });\n\n    const savedClone = await this.roleRepository.save(clone);\n\n    // Clone permissions\n    for (const rp of original.rolePermissions) {\n      await this.rolePermissionRepository.save({\n        role: savedClone,\n        permission: rp.permission,\n      });\n    }\n\n    this.logger.log(`Cloned role ID ${roleId} to ${savedClone.id}`);\n\n    // Audit log\n    await this.logSecurityEvent(\n      SecurityAuditAction.ROLE_CREATED,\n      savedClone.id,\n      `Role cloned from: ${original.name}`,\n      { originalRoleId: roleId, clonedRoleId: savedClone.id },\n    );\n\n    return savedClone;\n  }\n\n  // ============================================================\n  // NEW METHODS: ROLE TEMPLATES\n  // ============================================================\n\n  /**
   * Get all available role templates.\n   * Templates are pre-configured roles for common use cases.\n   *\n   * @returns Array of role templates\n   *\n   * @example\n   * const templates = await rolesService.getRoleTemplates();\n   * templates.forEach(t => console.log(t.name, t.description));\n   */\n  async getRoleTemplates(): Promise<RoleTemplate[]> {\n    return getRoleTemplates();\n  }\n\n  /**
   * Create a role from a template.\n   * Looks up permissions by name and assigns them to the new role.\n   *\n   * @param templateId - Template identifier\n   * @param customName - Optional custom name (overrides template name)\n   * @returns Created role with assigned permissions\n   * @throws NotFoundException if template not found\n   * @throws BadRequestException if permissions not found\n   *\n   * @example\n   * const role = await rolesService.createFromTemplate('customer-support');\n   * // or with custom name:\n   * const role = await rolesService.createFromTemplate('customer-support', 'Level 1 Support');\n   */\n  async createFromTemplate(templateId: string, customName?: string): Promise<Role> {\n    const template = getRoleTemplateById(templateId);\n    if (!template) {\n      throw new NotFoundException(`Template with ID '${templateId}' not found`);\n    }\n\n    // Handle 'all_permissions' special case for Super Admin\n    let permissionIds: number[];\n    if (template.permissionNames.includes('all_permissions')) {\n      const allPermissions = await this.permissionRepository.find();\n      permissionIds = allPermissions.map((p) => p.id);\n    } else {\n      // Look up permissions by name\n      const permissions = await this.permissionRepository.find({\n        where: {\n          name: In(template.permissionNames),\n        },\n      });\n\n      if (permissions.length !== template.permissionNames.length) {\n        const foundNames = permissions.map((p) => p.name);\n        const missing = template.permissionNames.filter((n) => !foundNames.includes(n));\n        this.logger.warn(\n          `Template '${templateId}' references missing permissions: ${missing.join(', ')}`,\n        );\n        throw new BadRequestException(\n          `Template references missing permissions: ${missing.join(', ')}`,\n        );\n      }\n\n      permissionIds = permissions.map((p) => p.id);\n    }\n\n    // Create role\n    const role = await this.create({\n      name: customName || template.name,\n      description: template.description,\n      isDefault: template.isDefault,\n      priority: template.priority,\n    });\n\n    // Assign permissions\n    await this.bulkAssignPermissions(role.id, { permissionIds });\n\n    this.logger.log(\n      `Created role from template '${templateId}': ${role.name} with ${permissionIds.length} permissions`,\n    );\n\n    return this.findOne(role.id); // Reload with permissions\n  }\n\n  // ============================================================\n  // NEW METHODS: BULK PERMISSION ASSIGNMENT\n  // ============================================================\n\n  /**
   * Bulk assign permissions to a role.\n   * Replaces all existing role permissions with the provided list.\n   * This operation is atomic - either all succeed or all fail.\n   *\n   * @param roleId - Role ID\n   * @param dto - Bulk assignment DTO with permission IDs\n   * @returns Updated role with new permissions\n   * @throws NotFoundException if role or permissions not found\n   * @throws BadRequestException if system role or invalid permissions\n   *\n   * @example\n   * await rolesService.bulkAssignPermissions(5, {\n   *   permissionIds: [1, 2, 3, 15, 20]\n   * });\n   */\n  async bulkAssignPermissions(\n    roleId: number,\n    dto: BulkAssignPermissionsDto,\n  ): Promise<Role> {\n    const role = await this.findOne(roleId);\n\n    // Cannot modify system roles\n    if (role.isDefault) {\n      throw new BadRequestException(\n        'Cannot modify permissions of a system role.',\n      );\n    }\n\n    // Validate all permission IDs exist\n    const permissions = await this.permissionRepository.find({\n      where: {\n        id: In(dto.permissionIds),\n      },\n    });\n\n    if (permissions.length !== dto.permissionIds.length) {\n      const foundIds = permissions.map((p) => p.id);\n      const missing = dto.permissionIds.filter((id) => !foundIds.includes(id));\n      throw new BadRequestException(\n        `Permission IDs not found: ${missing.join(', ')}`,\n      );\n    }\n\n    // Use transaction for atomicity\n    await this.dataSource.transaction(async (manager) => {\n      // Remove all existing role permissions\n      await manager.delete(RolePermission, { role: { id: roleId } });\n\n      // Insert new permissions in bulk\n      const rolePermissions = permissions.map((permission) =>\n        manager.create(RolePermission, {\n          role,\n          permission,\n        }),\n      );\n\n      await manager.save(RolePermission, rolePermissions);\n    });\n\n    this.logger.log(\n      `Bulk assigned ${dto.permissionIds.length} permissions to role ID ${roleId}`,\n    );\n\n    // Audit log\n    await this.logSecurityEvent(\n      SecurityAuditAction.PERMISSION_MODIFIED,\n      roleId,\n      `Bulk assigned ${dto.permissionIds.length} permissions to role: ${role.name}`,\n      { permissionIds: dto.permissionIds },\n    );\n\n    return this.findOne(roleId); // Reload with new permissions\n  }\n\n  /**
   * Remove a single permission from a role.\n   * Validates that the role will still have at least 1 permission after removal.\n   *\n   * @param roleId - Role ID\n   * @param permissionId - Permission ID to remove\n   * @throws NotFoundException if role or permission not found\n   * @throws BadRequestException if system role or last permission\n   *\n   * @example\n   * await rolesService.removePermission(5, 20);\n   */\n  async removePermission(roleId: number, permissionId: number): Promise<void> {\n    const role = await this.findOne(roleId);\n\n    // Cannot modify system roles\n    if (role.isDefault) {\n      throw new BadRequestException(\n        'Cannot modify permissions of a system role.',\n      );\n    }\n\n    // Check if permission exists on role\n    const rolePermission = await this.rolePermissionRepository.findOne({\n      where: {\n        role: { id: roleId },\n        permission: { id: permissionId },\n      },\n      relations: ['permission'],\n    });\n\n    if (!rolePermission) {\n      throw new NotFoundException(\n        `Permission ID ${permissionId} not assigned to role ID ${roleId}`,\n      );\n    }\n\n    // Cannot remove last permission\n    const permissionCount = role.rolePermissions.length;\n    if (permissionCount <= 1) {\n      throw new BadRequestException(\n        'Cannot remove the last permission from a role. Roles must have at least 1 permission.',\n      );\n    }\n\n    await this.rolePermissionRepository.remove(rolePermission);\n\n    this.logger.log(\n      `Removed permission ID ${permissionId} from role ID ${roleId}`,\n    );\n\n    // Audit log\n    await this.logSecurityEvent(\n      SecurityAuditAction.PERMISSION_MODIFIED,\n      roleId,\n      `Removed permission '${rolePermission.permission.name}' from role: ${role.name}`,\n      { permissionId, permissionName: rolePermission.permission.name },\n    );\n  }\n\n  // ============================================================\n  // NEW METHODS: USER ASSIGNMENT TRACKING\n  // ============================================================\n\n  /**
   * Get paginated list of users with a specific role.\n   * Searches both roleId (business role) and assignedRoleId (staff role).\n   *\n   * @param roleId - Role ID to query\n   * @param page - Page number (1-based)\n   * @param limit - Users per page (max 100)\n   * @returns Paginated list of users\n   *\   * @example\n   * const result = await rolesService.getUsersWithRole(5, 1, 20);\n   * console.log(`Found ${result.total} users with this role`);\n   */\n  async getUsersWithRole(\n    roleId: number,\n    page: number = 1,\n    limit: number = 20,\n  ): Promise<PaginatedResponseDto<UserWithRole>> {\n    // Validate role exists\n    await this.findOne(roleId);\n\n    const qb = this.userRepository\n      .createQueryBuilder('user')\n      .leftJoinAndSelect('user.role', 'role')\n      .leftJoinAndSelect('user.assignedRole', 'assignedRole')\n      .where('user.role.id = :roleId', { roleId })\n      .orWhere('user.assignedRole.id = :roleId', { roleId });\n\n    const [users, total] = await qb\n      .skip((page - 1) * limit)\n      .take(limit)\n      .orderBy('user.id', 'ASC')\n      .getManyAndCount();\n\n    const data: UserWithRole[] = users.map((user) => ({\n      id: user.id,\n      email: user.email,\n      fullName: user.fullName,\n      role: user.role,\n      assignedRole: user.assignedRole,\n    }));\n\n    return {\n      data,\n      total,\n      page,\n      limit,\n    };\n  }\n\n  /**
   * Get count of users assigned to a role.\n   * Counts both business roles and staff roles.\n   *\n   * @param roleId - Role ID\n   * @returns Total number of users with this role\n   *\n   * @example\n   * const count = await rolesService.getUserCountForRole(5);\n   * console.log(`${count} users have this role`);\n   */\n  async getUserCountForRole(roleId: number): Promise<number> {\n    const count = await this.userRepository\n      .createQueryBuilder('user')\n      .where('user.role.id = :roleId', { roleId })\n      .orWhere('user.assignedRole.id = :roleId', { roleId })\n      .getCount();\n\n    return count;\n  }\n\n  // ============================================================\n  // NEW METHODS: ROLE PRIORITY\n  // ============================================================\n\n  /**
   * Update role priority for hierarchy and conflict resolution.\n   * Higher priority roles take precedence when conflicts occur.\n   *\n   * @param roleId - Role ID\n   * @param dto - Priority update DTO\n   * @returns Updated role\n   * @throws BadRequestException if system role\n   *\n   * @example\n   * await rolesService.updateRolePriority(5, { priority: 60 });\n   */\n  async updateRolePriority(\n    roleId: number,\n    dto: UpdateRolePriorityDto,\n  ): Promise<Role> {\n    const role = await this.findOne(roleId);\n\n    // Cannot modify system role priority\n    if (role.isDefault) {\n      throw new BadRequestException(\n        'Cannot modify priority of a system role.',\n      );\n    }\n\n    const oldPriority = role.priority;\n    role.priority = dto.priority;\n    const updated = await this.roleRepository.save(role);\n\n    this.logger.log(\n      `Updated priority for role ID ${roleId}: ${oldPriority} -> ${dto.priority}`,\n    );\n\n    // Audit log\n    await this.logSecurityEvent(\n      SecurityAuditAction.ROLE_PRIORITY_MODIFIED,\n      roleId,\n      `Priority changed for role '${role.name}': ${oldPriority} -> ${dto.priority}`,\n      { oldPriority, newPriority: dto.priority },\n    );\n\n    return updated;\n  }\n\n  // ============================================================\n  // NEW METHODS: PERMISSION CONFLICT DETECTION\n  // ============================================================\n\n  /**
   * Detect potential conflicts in a set of permissions.\n   * Checks for missing dependencies, conflicting actions, and redundancies.\n   *\n   * @param permissionIds - Array of permission IDs to analyze\n   * @returns Array of detected conflicts with recommendations\n   *\n   * @example\n   * const conflicts = await rolesService.detectPermissionConflicts([1, 2, 3]);\n   * conflicts.forEach(c => console.log(c.message, c.recommendation));\n   */\n  async detectPermissionConflicts(\n    permissionIds: number[],\n  ): Promise<PermissionConflict[]> {\n    const conflicts: PermissionConflict[] = [];\n\n    // Fetch permissions\n    const permissions = await this.permissionRepository.find({\n      where: {\n        id: In(permissionIds),\n      },\n    });\n\n    const permissionNames = permissions.map((p) => p.name);\n\n    // Rule 1: Check for delete without view\n    const hasDelete = permissionNames.some((name) => name.includes('delete_'));\n    const hasView = permissionNames.some((name) => name.includes('view_'));\n    if (hasDelete && !hasView) {\n      conflicts.push({\n        type: 'MISSING_DEPENDENCY',\n        severity: 'MEDIUM',\n        message: 'Role has delete permissions without view permissions',\n        affectedPermissions: permissionNames.filter((n) => n.includes('delete_')),\n        recommendation: 'Add corresponding view permissions for better UX',\n      });\n    }\n\n    // Rule 2: Check for manage without view\n    const hasManage = permissionNames.some((name) => name.includes('manage_'));\n    if (hasManage && !hasView) {\n      conflicts.push({\n        type: 'MISSING_DEPENDENCY',\n        severity: 'HIGH',\n        message: 'Role has manage permissions without view permissions',\n        affectedPermissions: permissionNames.filter((n) => n.includes('manage_')),\n        recommendation: 'Add view permissions - manage implies view access',\n      });\n    }\n\n    // Rule 3: Check for ban/unban pair\n    const hasBan = permissionNames.includes('ban_users');\n    const hasUnban = permissionNames.includes('unban_users');\n    if (hasBan && !hasUnban) {\n      conflicts.push({\n        type: 'MISSING_DEPENDENCY',\n        severity: 'MEDIUM',\n        message: 'Role can ban users but cannot unban them',\n        affectedPermissions: ['ban_users'],\n        recommendation: 'Add unban_users permission for complete user management',\n      });\n    }\n\n    // Rule 4: Check for redundant permissions (manage includes view)\n    const managePermissions = permissionNames.filter((n) => n.includes('manage_'));\n    managePermissions.forEach((managePerm) => {\n      const resource = managePerm.replace('manage_', '');\n      const viewPerm = `view_${resource}`;\n      if (permissionNames.includes(viewPerm)) {\n        conflicts.push({\n          type: 'REDUNDANT_PERMISSION',\n          severity: 'LOW',\n          message: `'${managePerm}' already includes '${viewPerm}'`,\n          affectedPermissions: [managePerm, viewPerm],\n          recommendation: 'Remove view permission as manage permission covers it',\n        });\n      }\n    });\n\n    return conflicts;\n  }\n\n  // ============================================================\n  // HELPER METHODS\n  // ============================================================\n\n  /**
   * Log security events to audit trail.\n   * Wrapper around SecurityAuditService for consistent logging.\n   *\n   * @param action - Security action type\n   * @param roleId - Role ID affected\n   * @param message - Human-readable message\n   * @param metadata - Additional context\n   */\n  private async logSecurityEvent(\n    action: SecurityAuditAction,\n    roleId: number,\n    message: string,\n    metadata?: Record<string, any>,\n  ): Promise<void> {\n    try {\n      await this.securityAuditService.logPermissionCheck({\n        userId: null, // System action (no user context in service)\n        action,\n        resourceType: ResourceType.ROLE,\n        resourceId: roleId,\n        success: true,\n        ipAddress: 'system',\n        userAgent: 'RolesService',\n        requestPath: '/api/admin/roles',\n        requestMethod: 'SYSTEM',\n        metadata: {\n          message,\n          ...metadata,\n        },\n      });\n    } catch (error) {\n      // Don't fail the operation if audit logging fails\n      this.logger.error(`Failed to log security event: ${error.message}`);\n    }\n  }\n}\n