/**
 * @file cohort-analysis.service.ts
 * @description Cohort Analysis Service for Customer Lifecycle and Retention
 *
 * PURPOSE:
 * - Tracks customer cohorts by registration/acquisition period
 * - Measures retention rates over time
 * - Analyzes revenue patterns by cohort
 * - Identifies high-value cohorts and churn patterns
 * - Provides actionable insights for retention strategies
 *
 * COHORT TYPES:
 * - REGISTRATION: Grouped by signup month
 * - FIRST_PURCHASE: Grouped by first order month
 * - ACQUISITION_CHANNEL: Grouped by UTM source/medium
 *
 * RETENTION METRICS:
 * - Period retention rate (customers active in period N)
 * - Cumulative retention (customers still active)
 * - Revenue retention (revenue contribution over time)
 * - Churn rate per cohort period
 *
 * @author SouqSyria Development Team
 * @since 2026-01-22
 * @version 1.0.0
 */

import { Injectable, Logger } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository, Between, In, MoreThan } from 'typeorm';

// Entities
import { User } from '../../users/entities/user.entity';
import { Order } from '../../orders/entities/order.entity';
import { UserSession } from '../../analytics/entities/user-session.entity';
import { BusinessEvent, BusinessEventType } from '../entities/business-event.entity';

/**
 * Cohort period type
 */
export enum CohortPeriodType {
  MONTHLY = 'monthly',
  WEEKLY = 'weekly',
  QUARTERLY = 'quarterly',
}

/**
 * Cohort type classification
 */
export enum CohortType {
  REGISTRATION = 'registration',
  FIRST_PURCHASE = 'first_purchase',
  ACQUISITION_CHANNEL = 'acquisition_channel',
}

/**
 * Cohort definition
 */
export interface ICohort {
  /** Cohort identifier */
  cohortId: string;
  /** Cohort display name */
  cohortName: string;
  /** Cohort start date */
  startDate: Date;
  /** Cohort end date (for period cohorts) */
  endDate: Date;
  /** Number of customers in cohort */
  customerCount: number;
  /** Cohort type */
  type: CohortType;
  /** Additional metadata */
  metadata?: Record<string, any>;
}

/**
 * Cohort retention data point
 */
export interface ICohortRetentionDataPoint {
  /** Period index (0 = cohort period, 1 = next period, etc.) */
  periodIndex: number;
  /** Period label (e.g., "Month 0", "Month 1") */
  periodLabel: string;
  /** Number of customers active in this period */
  activeCustomers: number;
  /** Retention rate compared to cohort size (percentage) */
  retentionRate: number;
  /** Churn rate for this period (percentage) */
  churnRate: number;
  /** Revenue generated in this period */
  revenue: number;
  /** Average revenue per active customer */
  averageRevenuePerCustomer: number;
  /** Cumulative retention since cohort start */
  cumulativeRetention: number;
}

/**
 * Complete cohort retention analysis
 */
export interface ICohortRetentionAnalysis {
  /** Cohort being analyzed */
  cohort: ICohort;
  /** Retention data points over time */
  retentionData: ICohortRetentionDataPoint[];
  /** Overall cohort metrics */
  summary: {
    /** Total revenue generated by cohort */
    totalRevenue: number;
    /** Average lifetime value per customer */
    averageLTV: number;
    /** Current retention rate */
    currentRetentionRate: number;
    /** Periods tracked */
    periodsTracked: number;
    /** Days since cohort creation */
    daysSinceCohortStart: number;
  };
}

/**
 * Cohort comparison data
 */
export interface ICohortComparison {
  /** Cohorts being compared */
  cohorts: ICohort[];
  /** Retention comparison by period */
  retentionComparison: Array<{
    periodIndex: number;
    periodLabel: string;
    cohortRetentionRates: Record<string, number>; // cohortId -> retention rate
  }>;
  /** Revenue comparison */
  revenueComparison: Array<{
    cohortId: string;
    cohortName: string;
    totalRevenue: number;
    averageLTV: number;
  }>;
  /** Best performing cohort */
  bestCohort: {
    cohortId: string;
    cohortName: string;
    metric: 'retention' | 'revenue';
    value: number;
  };
}

/**
 * Cohort behavior patterns
 */
export interface ICohortBehaviorPattern {
  cohortId: string;
  cohortName: string;
  patterns: {
    /** Average days to second purchase */
    averageDaysToSecondPurchase: number;
    /** Percentage who made second purchase */
    secondPurchaseRate: number;
    /** Most popular product category */
    topCategory: string;
    /** Average order frequency (orders/month) */
    averageOrderFrequency: number;
    /** Peak engagement period */
    peakEngagementPeriod: number; // Period index
  };
}

/**
 * Cohort Analysis Service
 *
 * Comprehensive cohort analysis for customer retention, lifecycle tracking,
 * and revenue pattern analysis. Essential for understanding customer behavior
 * and optimizing retention strategies.
 *
 * @swagger
 * @ApiTags('Business Intelligence - Cohort Analysis')
 */
@Injectable()
export class CohortAnalysisService {
  private readonly logger = new Logger(CohortAnalysisService.name);

  constructor(
    @InjectRepository(User)
    private readonly userRepository: Repository<User>,

    @InjectRepository(Order)
    private readonly orderRepository: Repository<Order>,

    @InjectRepository(UserSession)
    private readonly userSessionRepository: Repository<UserSession>,

    @InjectRepository(BusinessEvent)
    private readonly businessEventRepository: Repository<BusinessEvent>,
  ) {
    this.logger.log('ðŸ“Š Cohort Analysis Service initialized');
  }

  /**
   * Get registration cohorts
   *
   * @param startDate - Start date for cohort analysis
   * @param endDate - End date for cohort analysis
   * @param periodType - Cohort period granularity
   * @returns Promise<ICohort[]> - Array of registration cohorts
   */
  async getRegistrationCohorts(
    startDate: Date,
    endDate: Date,
    periodType: CohortPeriodType = CohortPeriodType.MONTHLY,
  ): Promise<ICohort[]> {
    this.logger.log(`Getting registration cohorts from ${startDate.toISOString()} to ${endDate.toISOString()}`);

    try {
      const users = await this.userRepository.find({
        where: {
          createdAt: Between(startDate, endDate),
        },
        order: { createdAt: 'ASC' },
      });

      const cohorts = this.groupIntoCohorts(users, periodType, CohortType.REGISTRATION);
      this.logger.debug(`Found ${cohorts.length} registration cohorts`);

      return cohorts;
    } catch (error: unknown) {
      this.logger.error(`Failed to get registration cohorts: ${(error as Error).message}`);
      throw error;
    }
  }

  /**
   * Analyze retention for a specific cohort
   *
   * @param cohortId - Cohort identifier
   * @param periodType - Period granularity for retention tracking
   * @returns Promise<ICohortRetentionAnalysis> - Cohort retention analysis
   */
  async analyzeCohortRetention(
    cohortId: string,
    periodType: CohortPeriodType = CohortPeriodType.MONTHLY,
  ): Promise<ICohortRetentionAnalysis> {
    this.logger.log(`Analyzing retention for cohort: ${cohortId}`);

    try {
      // Parse cohort ID (format: "registration_2026-01" or "first_purchase_2026-01")
      const [type, dateStr] = cohortId.split('_');
      const cohortStartDate = new Date(dateStr);
      const cohortEndDate = this.getNextPeriodDate(cohortStartDate, periodType);

      // Get cohort customers
      const cohortCustomers = await this.userRepository.find({
        where: {
          createdAt: Between(cohortStartDate, cohortEndDate),
        },
      });

      const customerIds = cohortCustomers.map(c => c.id);
      const cohortSize = customerIds.length;

      this.logger.debug(`Cohort has ${cohortSize} customers`);

      // Calculate retention over time
      const now = new Date();
      const periodsToTrack = this.calculatePeriodsBetween(cohortStartDate, now, periodType);
      const retentionData: ICohortRetentionDataPoint[] = [];

      let totalRevenue = 0;

      for (let periodIndex = 0; periodIndex <= periodsToTrack; periodIndex++) {
        const periodStart = this.addPeriods(cohortStartDate, periodIndex, periodType);
        const periodEnd = this.addPeriods(cohortStartDate, periodIndex + 1, periodType);

        // Get active customers in this period (made a purchase)
        const periodOrders = await this.orderRepository
          .createQueryBuilder('o')
          .where('o.user IN (:...customerIds)', { customerIds })
          .andWhere('o.created_at BETWEEN :start AND :end', { start: periodStart, end: periodEnd })
          .andWhere('o.status = :status', { status: 'completed' })
          .getMany();

        const activeCustomerIds = new Set(periodOrders.map(o => o.user));
        const activeCount = activeCustomerIds.size;
        const periodRevenue = periodOrders.reduce((sum, o) => sum + Number(o.total_amount || 0), 0);
        totalRevenue += periodRevenue;

        const retentionRate = cohortSize > 0 ? (activeCount / cohortSize) * 100 : 0;
        const churnRate = 100 - retentionRate;

        retentionData.push({
          periodIndex,
          periodLabel: this.getPeriodLabel(periodIndex, periodType),
          activeCustomers: activeCount,
          retentionRate: Math.round(retentionRate * 10) / 10,
          churnRate: Math.round(churnRate * 10) / 10,
          revenue: Math.round(periodRevenue),
          averageRevenuePerCustomer: activeCount > 0
            ? Math.round(periodRevenue / activeCount)
            : 0,
          cumulativeRetention: retentionRate,
        });
      }

      const daysSinceCohortStart = Math.floor(
        (now.getTime() - cohortStartDate.getTime()) / (1000 * 60 * 60 * 24)
      );

      const cohort: ICohort = {
        cohortId,
        cohortName: `${this.getCohortTypeName(type as CohortType)} - ${dateStr}`,
        startDate: cohortStartDate,
        endDate: cohortEndDate,
        customerCount: cohortSize,
        type: type as CohortType,
      };

      return {
        cohort,
        retentionData,
        summary: {
          totalRevenue: Math.round(totalRevenue),
          averageLTV: cohortSize > 0 ? Math.round(totalRevenue / cohortSize) : 0,
          currentRetentionRate: retentionData[retentionData.length - 1]?.retentionRate || 0,
          periodsTracked: periodsToTrack + 1,
          daysSinceCohortStart,
        },
      };
    } catch (error: unknown) {
      this.logger.error(`Failed to analyze cohort retention: ${(error as Error).message}`);
      throw error;
    }
  }

  /**
   * Compare multiple cohorts
   *
   * @param cohortIds - Array of cohort identifiers
   * @param periodType - Period granularity
   * @returns Promise<ICohortComparison> - Cohort comparison
   */
  async compareCohorts(
    cohortIds: string[],
    periodType: CohortPeriodType = CohortPeriodType.MONTHLY,
  ): Promise<ICohortComparison> {
    this.logger.log(`Comparing ${cohortIds.length} cohorts`);

    try {
      // Analyze each cohort
      const analyses = await Promise.all(
        cohortIds.map(id => this.analyzeCohortRetention(id, periodType))
      );

      const cohorts = analyses.map(a => a.cohort);

      // Find maximum periods tracked
      const maxPeriods = Math.max(...analyses.map(a => a.retentionData.length));

      // Build retention comparison
      const retentionComparison: ICohortComparison['retentionComparison'] = [];
      for (let periodIndex = 0; periodIndex < maxPeriods; periodIndex++) {
        const cohortRetentionRates: Record<string, number> = {};

        for (const analysis of analyses) {
          const dataPoint = analysis.retentionData[periodIndex];
          if (dataPoint) {
            cohortRetentionRates[analysis.cohort.cohortId] = dataPoint.retentionRate;
          }
        }

        retentionComparison.push({
          periodIndex,
          periodLabel: this.getPeriodLabel(periodIndex, periodType),
          cohortRetentionRates,
        });
      }

      // Revenue comparison
      const revenueComparison = analyses.map(a => ({
        cohortId: a.cohort.cohortId,
        cohortName: a.cohort.cohortName,
        totalRevenue: a.summary.totalRevenue,
        averageLTV: a.summary.averageLTV,
      }));

      // Determine best cohort
      const bestByRetention = analyses.reduce((best, current) =>
        current.summary.currentRetentionRate > best.summary.currentRetentionRate ? current : best
      );

      const bestByRevenue = analyses.reduce((best, current) =>
        current.summary.totalRevenue > best.summary.totalRevenue ? current : best
      );

      const bestCohort = {
        cohortId: bestByRevenue.cohort.cohortId,
        cohortName: bestByRevenue.cohort.cohortName,
        metric: 'revenue' as const,
        value: bestByRevenue.summary.totalRevenue,
      };

      return {
        cohorts,
        retentionComparison,
        revenueComparison,
        bestCohort,
      };
    } catch (error: unknown) {
      this.logger.error(`Failed to compare cohorts: ${(error as Error).message}`);
      throw error;
    }
  }

  /**
   * Get cohort behavior patterns
   *
   * @param cohortId - Cohort identifier
   * @returns Promise<ICohortBehaviorPattern> - Behavior patterns
   */
  async getCohortBehaviorPatterns(cohortId: string): Promise<ICohortBehaviorPattern> {
    this.logger.log(`Analyzing behavior patterns for cohort: ${cohortId}`);

    try {
      const [type, dateStr] = cohortId.split('_');
      const cohortStartDate = new Date(dateStr);
      const cohortEndDate = this.getNextPeriodDate(cohortStartDate, CohortPeriodType.MONTHLY);

      // Get cohort customers
      const cohortCustomers = await this.userRepository.find({
        where: {
          createdAt: Between(cohortStartDate, cohortEndDate),
        },
      });

      const customerIds = cohortCustomers.map(c => c.id);

      // Get all orders for cohort
      const orders = await this.orderRepository
        .createQueryBuilder('o')
        .leftJoinAndSelect('o.items', 'items')
        .leftJoinAndSelect('items.product', 'product')
        .leftJoinAndSelect('product.category', 'category')
        .where('o.user IN (:...customerIds)', { customerIds })
        .andWhere('o.status = :status', { status: 'completed' })
        .orderBy('o.created_at', 'ASC')
        .getMany();

      // Calculate second purchase metrics
      const secondPurchaseData: number[] = [];
      const customerOrderMap = new Map<number, Order[]>();

      for (const order of orders) {
        if (!customerOrderMap.has(order.user.id)) {
          customerOrderMap.set(order.user.id, []);
        }
        customerOrderMap.get(order.user.id)!.push(order);
      }

      for (const [userId, userOrders] of customerOrderMap.entries()) {
        if (userOrders.length >= 2) {
          const daysBetween = Math.floor(
            (userOrders[1].created_at.getTime() - userOrders[0].created_at.getTime()) / (1000 * 60 * 60 * 24)
          );
          secondPurchaseData.push(daysBetween);
        }
      }

      const averageDaysToSecondPurchase = secondPurchaseData.length > 0
        ? secondPurchaseData.reduce((sum, d) => sum + d, 0) / secondPurchaseData.length
        : 0;

      const secondPurchaseRate = customerIds.length > 0
        ? (secondPurchaseData.length / customerIds.length) * 100
        : 0;

      // Find top category
      const categoryCount = new Map<string, number>();
      for (const order of orders) {
        for (const item of order.items || []) {
          const categoryName = item.variant?.product?.category?.nameEn || 'Unknown';
          categoryCount.set(categoryName, (categoryCount.get(categoryName) || 0) + 1);
        }
      }

      const topCategory = Array.from(categoryCount.entries())
        .sort((a, b) => b[1] - a[1])[0]?.[0] || 'Unknown';

      // Calculate order frequency
      const now = new Date();
      const cohortAgeDays = Math.max(1, Math.floor(
        (now.getTime() - cohortStartDate.getTime()) / (1000 * 60 * 60 * 24)
      ));
      const averageOrderFrequency = (orders.length / customerIds.length) / (cohortAgeDays / 30);

      return {
        cohortId,
        cohortName: `${this.getCohortTypeName(type as CohortType)} - ${dateStr}`,
        patterns: {
          averageDaysToSecondPurchase: Math.round(averageDaysToSecondPurchase),
          secondPurchaseRate: Math.round(secondPurchaseRate * 10) / 10,
          topCategory,
          averageOrderFrequency: Math.round(averageOrderFrequency * 100) / 100,
          peakEngagementPeriod: 0, // Would need more sophisticated analysis
        },
      };
    } catch (error: unknown) {
      this.logger.error(`Failed to get cohort behavior patterns: ${(error as Error).message}`);
      throw error;
    }
  }

  /**
   * Get all cohorts for a date range
   *
   * @param startDate - Start date
   * @param endDate - End date
   * @param periodType - Period type
   * @param cohortType - Cohort type
   * @returns Promise<ICohort[]> - Array of cohorts
   */
  async getAllCohorts(
    startDate: Date,
    endDate: Date,
    periodType: CohortPeriodType = CohortPeriodType.MONTHLY,
    cohortType: CohortType = CohortType.REGISTRATION,
  ): Promise<ICohort[]> {
    switch (cohortType) {
      case CohortType.REGISTRATION:
        return this.getRegistrationCohorts(startDate, endDate, periodType);
      case CohortType.FIRST_PURCHASE:
        return this.getFirstPurchaseCohorts(startDate, endDate, periodType);
      default:
        throw new Error(`Unsupported cohort type: ${cohortType}`);
    }
  }

  /**
   * Get first purchase cohorts
   */
  private async getFirstPurchaseCohorts(
    startDate: Date,
    endDate: Date,
    periodType: CohortPeriodType,
  ): Promise<ICohort[]> {
    // Get first orders in date range
    const firstOrders = await this.orderRepository
      .createQueryBuilder('o')
      .where('o.created_at BETWEEN :start AND :end', { start: startDate, end: endDate })
      .andWhere('o.status = :status', { status: 'completed' })
      .orderBy('o.user', 'ASC')
      .addOrderBy('o.created_at', 'ASC')
      .getMany();

    // Filter to first order per user
    const firstOrderMap = new Map<number, Order>();
    for (const order of firstOrders) {
      if (!firstOrderMap.has(order.user.id)) {
        firstOrderMap.set(order.user.id, order);
      }
    }

    const firstOrdersOnly = Array.from(firstOrderMap.values());

    // Group into cohorts by order date
    return this.groupOrdersIntoCohorts(firstOrdersOnly, periodType, CohortType.FIRST_PURCHASE);
  }

  /**
   * Group users into cohorts
   */
  private groupIntoCohorts(
    users: User[],
    periodType: CohortPeriodType,
    cohortType: CohortType,
  ): ICohort[] {
    const cohortMap = new Map<string, User[]>();

    for (const user of users) {
      const cohortKey = this.getCohortKey(user.createdAt, periodType);

      if (!cohortMap.has(cohortKey)) {
        cohortMap.set(cohortKey, []);
      }

      cohortMap.get(cohortKey)!.push(user);
    }

    const cohorts: ICohort[] = [];

    for (const [key, cohortUsers] of cohortMap.entries()) {
      const startDate = this.parseCohortKey(key, periodType);
      const endDate = this.getNextPeriodDate(startDate, periodType);

      cohorts.push({
        cohortId: `${cohortType}_${key}`,
        cohortName: `${this.getCohortTypeName(cohortType)} - ${key}`,
        startDate,
        endDate,
        customerCount: cohortUsers.length,
        type: cohortType,
      });
    }

    return cohorts.sort((a, b) => a.startDate.getTime() - b.startDate.getTime());
  }

  /**
   * Group orders into cohorts
   */
  private groupOrdersIntoCohorts(
    orders: Order[],
    periodType: CohortPeriodType,
    cohortType: CohortType,
  ): ICohort[] {
    const cohortMap = new Map<string, Order[]>();

    for (const order of orders) {
      const cohortKey = this.getCohortKey(order.created_at, periodType);

      if (!cohortMap.has(cohortKey)) {
        cohortMap.set(cohortKey, []);
      }

      cohortMap.get(cohortKey)!.push(order);
    }

    const cohorts: ICohort[] = [];

    for (const [key, cohortOrders] of cohortMap.entries()) {
      const startDate = this.parseCohortKey(key, periodType);
      const endDate = this.getNextPeriodDate(startDate, periodType);

      cohorts.push({
        cohortId: `${cohortType}_${key}`,
        cohortName: `${this.getCohortTypeName(cohortType)} - ${key}`,
        startDate,
        endDate,
        customerCount: cohortOrders.length,
        type: cohortType,
      });
    }

    return cohorts.sort((a, b) => a.startDate.getTime() - b.startDate.getTime());
  }

  /**
   * Get cohort key from date
   */
  private getCohortKey(date: Date, periodType: CohortPeriodType): string {
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const week = String(Math.ceil(date.getDate() / 7)).padStart(2, '0');
    const quarter = String(Math.ceil((date.getMonth() + 1) / 3)).padStart(2, '0');

    switch (periodType) {
      case CohortPeriodType.WEEKLY:
        return `${year}-W${week}`;
      case CohortPeriodType.QUARTERLY:
        return `${year}-Q${quarter}`;
      case CohortPeriodType.MONTHLY:
      default:
        return `${year}-${month}`;
    }
  }

  /**
   * Parse cohort key to date
   */
  private parseCohortKey(key: string, periodType: CohortPeriodType): Date {
    // Simple parsing (would need more robust logic for all cases)
    const [year, period] = key.split('-');
    return new Date(parseInt(year), parseInt(period) - 1, 1);
  }

  /**
   * Get next period date
   */
  private getNextPeriodDate(date: Date, periodType: CohortPeriodType): Date {
    const nextDate = new Date(date);

    switch (periodType) {
      case CohortPeriodType.WEEKLY:
        nextDate.setDate(nextDate.getDate() + 7);
        break;
      case CohortPeriodType.QUARTERLY:
        nextDate.setMonth(nextDate.getMonth() + 3);
        break;
      case CohortPeriodType.MONTHLY:
      default:
        nextDate.setMonth(nextDate.getMonth() + 1);
    }

    return nextDate;
  }

  /**
   * Add periods to date
   */
  private addPeriods(date: Date, periods: number, periodType: CohortPeriodType): Date {
    const newDate = new Date(date);

    switch (periodType) {
      case CohortPeriodType.WEEKLY:
        newDate.setDate(newDate.getDate() + (periods * 7));
        break;
      case CohortPeriodType.QUARTERLY:
        newDate.setMonth(newDate.getMonth() + (periods * 3));
        break;
      case CohortPeriodType.MONTHLY:
      default:
        newDate.setMonth(newDate.getMonth() + periods);
    }

    return newDate;
  }

  /**
   * Calculate periods between dates
   */
  private calculatePeriodsBetween(startDate: Date, endDate: Date, periodType: CohortPeriodType): number {
    const diffMs = endDate.getTime() - startDate.getTime();
    const diffDays = diffMs / (1000 * 60 * 60 * 24);

    switch (periodType) {
      case CohortPeriodType.WEEKLY:
        return Math.floor(diffDays / 7);
      case CohortPeriodType.QUARTERLY:
        return Math.floor(diffDays / 90);
      case CohortPeriodType.MONTHLY:
      default:
        return Math.floor(diffDays / 30);
    }
  }

  /**
   * Get period label
   */
  private getPeriodLabel(periodIndex: number, periodType: CohortPeriodType): string {
    switch (periodType) {
      case CohortPeriodType.WEEKLY:
        return `Week ${periodIndex}`;
      case CohortPeriodType.QUARTERLY:
        return `Quarter ${periodIndex}`;
      case CohortPeriodType.MONTHLY:
      default:
        return `Month ${periodIndex}`;
    }
  }

  /**
   * Get cohort type name
   */
  private getCohortTypeName(type: CohortType): string {
    switch (type) {
      case CohortType.REGISTRATION:
        return 'Registration';
      case CohortType.FIRST_PURCHASE:
        return 'First Purchase';
      case CohortType.ACQUISITION_CHANNEL:
        return 'Acquisition Channel';
      default:
        return 'Unknown';
    }
  }
}
